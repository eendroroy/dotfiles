#!/usr/bin/env bash

# Copyright (C) Indrajit Roy <eendroroy@gmail.com>
#
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

__CURRENT_DIR=$(pwd)
__SUCCESS_SYMBOL=" ░"
__ERROR_SYMBOL=" ░"
__PRIMARY_SYMBOL=" ━"

__handle_stdout() {
  while IFS= read -r line; do
    printf "\e[38;5;2m%s\e[0m  %s\n" "${__SUCCESS_SYMBOL}" "${line}"
  done
}

__handle_stderr() {
  while IFS= read -r line; do
    printf "\e[38;5;1m%s\e[0m  %s\n" "${__ERROR_SYMBOL}" "${line}" 1>&2
  done
}

__match_filter() {
  local value="$1" pattern="$2"

  # Interpret anchors: ^ = prefix, $ = suffix, ^...$ = exact
  local anchored_start anchored_end
  if [[ "$pattern" == \^* ]]; then
    anchored_start=1
    pattern="${pattern#^}"
  fi
  if [[ "$pattern" == *\$ ]]; then
    anchored_end=1
    pattern="${pattern%\$}"
  fi

  if [[ -n "$anchored_start" && -n "$anchored_end" ]]; then
    [[ "$value" == "$pattern" ]]
  elif [[ -n "$anchored_start" ]]; then
    [[ "$value" == "$pattern"* ]]
  elif [[ -n "$anchored_end" ]]; then
    [[ "$value" == *"$pattern" ]]
  else
    [[ "$value" == *"$pattern"* ]]
  fi
}

__repo_status() {
  (
    if ! cd "${1}" 2>/dev/null; then
      echo -e "\e[38;5;1m${__PRIMARY_SYMBOL}\e[0m  \e[38;5;9mFailed to enter: ${1}\e[0m" 1>&2
      exit 1
    fi

    printf "\e[38;5;2m${__PRIMARY_SYMBOL}\e[0m \e[32m%s\e[m \e[33m%s\e[m \e[35m%s\e[m \e[33m%s\e[m \e[96m%s\e[m\n" \
      "$(git branch --show-current)" \
      "$(git log -1 --format="%h" --abbrev=8)" \
      "${PWD/"${__CURRENT_DIR}"/.}" \
      "$(git log -1 --format="%cr")" \
      "$(git log -1 --format="%ae")"
  )
}

__help() {
  echo
  echo -e "\e[1;37mGitter\e[0m"
  echo -e "  Run git or arbitrary command in multiple git repositories with filters in current directory"
  echo
  echo -e "\e[1;37mUsage:\e[0m"
  echo -ne "  \e[32mgitter\e[0m [\e[36m--filter-exclude\e[0m] [\e[36m--filter <pattern>\e[0m ...]"
  echo -ne " [\e[36m--git\e[0m|\e[36m--exe\e[0m|\e[36m--list\e[0m|\e[36m--help\e[0m]"
  echo -ne " \e[36m--\e[0m"
  echo -e " [\e[33margs...\e[0m]"
  echo
  echo -e "\e[1;37mOptions:\e[0m"
  echo -e "  \e[36m--filter-exclude, -e           \e[0m Exclude matches instead of including them (\e[33minclude by default\e[0m)"
  echo -e "  \e[36m--filter,         -f <pattern> \e[0m Match repo directory name exactly"
  echo -e "  \e[36m--git,            -g           \e[0m Run a git command (\e[33mdefault\e[0m)"
  echo -e "  \e[36m--exe,            -x           \e[0m Run an arbitrary command"
  echo -e "  \e[36m--list,           -l           \e[0m List repositories only"
  echo -e "  \e[36m--help,           -h           \e[0m Show this help menu"
  echo -e "  \e[33margs                           \e[0m Arguments passed to the chosen command"
  echo
  echo -e "\e[1;37mPatterns:\e[0m"
  echo -e "  \e[31mP:           \e[0m Match for path name"
  echo -e "  \e[31mR:           \e[0m Match for repo name"
  echo -e "  \e[31mB:           \e[0m Match for current git branch"
  echo -e "  \e[31m^\e[0m\e[2;38;5;3m<pattern>\e[0m\e[31m$  \e[0m Exact match"
  echo -e "  \e[31m^\e[0m\e[2;38;5;3m<pattern>   \e[0m Prefix match"
  echo -e "   \e[2;38;5;3m<pattern>\e[0m\e[31m$  \e[0m Suffix match"
  echo -e "   \e[2;38;5;3m<pattern>   \e[0m Substring match"
  echo
  echo -e "\e[1;37mExamples:\e[0m"
  echo -ne "  \e[32mgitter\e[0m \e[36m--filter R:^my-repo$\e[0m \e[36m--git\e[0m \e[36m--\e[0m \e[33mstatus\e[0m"
  echo -e "           - Run \e[33mgit status\e[0m in the repository named \e[35mmy-repo\e[0m"
  echo -ne "  \e[32mgitter\e[0m \e[36m--filter B:feature\e[0m \e[36m--exe\e[0m \e[36m--\e[0m \e[33mmake build\e[0m"
  echo -e "         - Run \e[33mmake build\e[0m in repositories currently on any \e[35mfeature\e[0m branch"
  echo -ne "  \e[32mgitter\e[0m \e[36m--filter-exclude\e[0m \e[36m--filter R:old-project\e[0m \e[36m--list\e[0m"
  echo -e " - List all repositories except the ones has \e[35mold-project\e[0m in repo name"
  echo
}

__parse_command() {
  if [[ -n "$command" ]]; then
    echo
    echo -e "\n\e[31mMultiple command types specified\e[0m" 1>&2
    echo
    echo -e "Run \e[32mgitter --help\e[0m for usage information." 1>&2
    echo
    exit 1
  fi
  command="${1}"
}

__accept_no_arg() {
  if [[ -n $1 ]]; then
    echo
    echo -e "\e[31mUnknown argument:\e[0m $1" 1>&2
    echo
    echo -e "Run \e[32mgitter --help\e[0m for usage information." 1>&2
    echo
    exit 1
  fi
}

__require_value() {
  if [[ -z "$1" || "$1" == -* ]]; then
    echo
    echo -e "\e[31mMissing or invalid argument for:\e[0m $2" 1>&2
    echo
    echo -e "Run \e[32mgitter --help\e[0m for usage information." 1>&2
    echo
    exit 1
  fi
}

# Argument defaults
command=""
filter_type="i"
has_filters=false
filters=()
args=()

if [[ $# -eq 0 ]]; then
  __help
  exit 1
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --help)
      __parse_command ""
      __help
      exit 0
      ;;
    --filter-exclude|-e)
      filter_type="e"
      shift
      ;;
    --filter|-f)
      shift
      __require_value "$1" "\e[36m--filter-name\e[0m"
      has_filters=true
      filters+=("$1")
      shift
      ;;
    --git|-g)
      __parse_command "git"
      shift
      ;;
    --exe|-x)
      __parse_command "exec"
      shift
      ;;
    --list|-l)
      __parse_command "list"
      shift
      ;;
    --)
      shift
      while [[ $# -gt 0 ]]; do
        args+=("$1")
        shift
      done
      ;;
    *)
      echo
      echo -e "\e[31mUnknown argument:\e[0m $1" 1>&2
      echo
      echo -e "Run \e[32mgitter --help\e[0m for usage information." 1>&2
      echo
      exit 1
      ;;
  esac
done

# Set default command type if none specified
[[ -z "$command" ]] && command="git"

[[ "$command" != "list" && ${#args[@]} -eq 0 ]] && {
  echo
  echo -e "\e[31mNo arguments provided for command:\e[0m $command" 1>&2
  echo
  echo -e "Run \e[32mgitter --help\e[0m for usage information." 1>&2
  echo
  exit 1
}

readarray -d '' -t repo_git_dirs < <(find . -name ".git" -type d -print0)

if [[ ${#repo_git_dirs[@]} -eq 0 ]]; then
  echo -e "\e[38;5;9m${__ERROR_SYMBOL}\e[0m  \e[38;5;9mNo git repositories found in the current directory\e[0m" 1>&2
  exit 1
fi

filtered_repo_git_dirs=()

for repo_git_dir in "${repo_git_dirs[@]}"; do
  # If no filters, include all repositories
  [[ "$has_filters" == false ]] && filtered_repo_git_dirs+=("$repo_git_dir") && continue

  git_branch=$(git -C "$repo_git_dir" branch --show-current 2>/dev/null)

  match=false
  for filter in "${filters[@]}"
  do
    filter_key="${filter%%:*}"
    filter_value="${filter#*:}"

    case "$filter_key" in
      P)
        if __match_filter "$(dirname "$repo_git_dir")" "$filter_value"; then
          match=true
          break
        fi
        ;;
      R)
        if __match_filter "$(basename "$(dirname "$repo_git_dir")")" "$filter_value"; then
          match=true
          break
        fi
        ;;
      B)
        if __match_filter "$git_branch" "$filter_value"; then
          match=true
          break
        fi
        ;;
      *)
        echo -e "\e[38;5;9m${__ERROR_SYMBOL}\e[0m  \e[38;5;9mUnknown filter key: ${filter_key}\e[0m" 1>&2
        exit 1
        ;;
    esac
  done

  # Apply include/exclude logic
  if [[ "$filter_type" == "i" && "$match" == true ]]; then
    filtered_repo_git_dirs+=("$repo_git_dir")
  elif [[ "$filter_type" == "e" && "$match" == false ]]; then
    filtered_repo_git_dirs+=("$repo_git_dir")
  fi
done

if [[ ${#filtered_repo_git_dirs[@]} -eq 0 ]]; then
  echo -e "\e[38;5;9m${__ERROR_SYMBOL}\e[0m  No git repositories found in the current directory with applied filters" 1>&2
  exit 1
fi

for repo_git_dir in "${filtered_repo_git_dirs[@]}"; do
  repo_dir=$(dirname "$repo_git_dir")
  if [[ "$command" == "list" ]]; then
    __repo_status "$repo_dir"
    continue
  fi
  if [[ "$command" == "git" || "$command" == "exec" ]]; then
    echo -e "\e[38;5;2m${__PRIMARY_SYMBOL} \e[1;38;5;2m(${command} ${args[*]})\e[m \e[90min\e[m \e[35m$repo_dir\e[m"
    (
      cd "$repo_dir" 2>/dev/null || {
        echo -e "\e[38;5;1m${__PRIMARY_SYMBOL}\e[0m  \e[38;5;9mFailed to enter: ${repo_dir}\e[0m" 1>&2
        exit 1
      }
      "$command" "${args[@]}" 1> >(__handle_stdout) 2> >(__handle_stderr)
    )
  fi
done