#!/usr/bin/env bash

# Copyright (C) Indrajit Roy <eendroroy@gmail.com>
#
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

____CURRENT_DIR=$(pwd)
_SUCCESS_SYMBOL=" ░"
___ERROR_SYMBOL=" ░"
_PRIMARY_SYMBOL=" ━"

_C___RESET='\e[0m'
_C____PATH='\e[35m'
_C_COMMAND='\e[32m'
_C____ARGS='\e[33m'
_C__OPTION='\e[36m'
_C_____DIM='\e[2;38;5;3m'
_C_SUCCESS='\e[38;5;2m'
_C___ERROR='\e[38;5;9m'
_C_HEADING='\e[1;37m'

__handle_stdout() {
  while IFS= read -r line; do
    printf "${_C_SUCCESS}%s${_C___RESET}  %s\n" "${_SUCCESS_SYMBOL}" "${line}"
  done
}

__handle_stderr() {
  while IFS= read -r line; do
    printf "${_C___ERROR}%s${_C___RESET}  %s\n" "${___ERROR_SYMBOL}" "${line}" 1>&2
  done
}

__match_filter() {
  local value="$1" pattern="$2"

  # Interpret anchors: ^ = prefix, $ = suffix, ^...$ = exact
  local anchored_start anchored_end
  if [[ "$pattern" == \^* ]]; then
    anchored_start=1
    pattern="${pattern#^}"
  fi
  if [[ "$pattern" == *\$ ]]; then
    anchored_end=1
    pattern="${pattern%\$}"
  fi

  if [[ -n "$anchored_start" && -n "$anchored_end" ]]; then
    [[ "$value" == "$pattern" ]]
  elif [[ -n "$anchored_start" ]]; then
    [[ "$value" == "$pattern"* ]]
  elif [[ -n "$anchored_end" ]]; then
    [[ "$value" == *"$pattern" ]]
  else
    [[ "$value" == *"$pattern"* ]]
  fi
}

__repo_status() {
  (
    cd "$1" 2>/dev/null || {
      echo -e "${_C___ERROR}${_PRIMARY_SYMBOL}  Failed to enter: ${1}${_C___RESET}" 1>&2
      exit 1
    }

    echo -ne "${_C_SUCCESS}${_PRIMARY_SYMBOL}${_C___RESET}"
    echo -ne " ${_C_COMMAND}$(git branch --show-current)${_C___RESET}"
    echo -ne " ${_C____ARGS}$(git log -1 --format="%h" --abbrev=8)${_C___RESET}"
    echo -ne " ${_C____PATH}${PWD/"${____CURRENT_DIR}"/.}${_C___RESET}"
    echo -ne " ${_C____ARGS}$(git log -1 --format="%cr")${_C___RESET}"
    echo  -e " ${_C__OPTION}$(git log -1 --format="%ae")${_C___RESET}"
  )
}

__help() {
  echo
  echo -e "${_C_HEADING}Gitter${_C___RESET}"
  echo -e "  Run git or arbitrary command in multiple git repositories with filters in current directory"
  echo
  echo -e "${_C_HEADING}Usage:${_C___RESET}"
  echo -ne "  ${_C_COMMAND}gitter${_C___RESET} [${_C__OPTION}--filter <pattern>${_C___RESET} ...]"
  echo -ne " [${_C__OPTION}git${_C___RESET}|${_C__OPTION}exec${_C___RESET}|${_C__OPTION}list${_C___RESET}|${_C__OPTION}help${_C___RESET}]"
  echo -ne " ${_C__OPTION}--${_C___RESET}"
  echo -e " [${_C____ARGS}args...${_C___RESET}]"
  echo
  echo -e "${_C_HEADING}Commands:${_C___RESET}"
  echo -e "  ${_C__OPTION}git   g      ${_C___RESET} Run a git command (${_C____ARGS}default${_C___RESET})"
  echo -e "  ${_C__OPTION}exec  x      ${_C___RESET} Run an arbitrary command"
  echo -e "  ${_C__OPTION}list  ls     ${_C___RESET} List repositories only"
  echo -e "  ${_C__OPTION}help  h      ${_C___RESET} Show this help menu"
  echo -e "  ${_C____ARGS}args         ${_C___RESET} Arguments passed to the chosen command"
  echo
  echo -e "${_C_HEADING}Options:${_C___RESET}"
  echo -e "  ${_C__OPTION}--filter   -f <pattern> ${_C___RESET} Match repo directory name exactly"
  echo -e "  ${_C__OPTION}--no-color              ${_C___RESET} Disable colored output"
  echo
  echo -e "${_C_HEADING}Patterns:${_C___RESET}"
  echo -ne "  ${_C_____DIM}[${_C___RESET}${_C___ERROR}sign_prefix${_C___RESET}${_C_____DIM}]${_C___RESET}"
  echo -ne   "${_C_____DIM}<${_C___RESET}${_C___ERROR}filter_prefix${_C___RESET}${_C_____DIM}>${_C___RESET}"
  echo -ne   "${_C_____DIM}<${_C___RESET}${_C_HEADING}:${_C___RESET}${_C_____DIM}>${_C___RESET}"
  echo -ne   "${_C_____DIM}[${_C___RESET}${_C___ERROR}prefix_match${_C___RESET}${_C_____DIM}]${_C___RESET}"
  echo -ne   "${_C_____DIM}<${_C___RESET}${_C____PATH}pattern${_C___RESET}${_C_____DIM}>${_C___RESET}"
  echo  -e   "${_C_____DIM}[${_C___RESET}${_C___ERROR}suffix_match${_C___RESET}${_C_____DIM}]${_C___RESET}"
  echo
  echo -e "  ${_C___ERROR}.${_C___RESET}            ${_C___RESET} Exclude sign prefix (${_C___ERROR}include ${_C____ARGS}by default${_C___RESET})"
  echo -e "  ${_C___ERROR}P:${_C___RESET}, ${_C___ERROR}path:${_C___RESET}     Match for path name"
  echo -e "  ${_C___ERROR}R:${_C___RESET}, ${_C___ERROR}repo:${_C___RESET}     Match for repo name"
  echo -e "  ${_C___ERROR}B:${_C___RESET}, ${_C___ERROR}branch:${_C___RESET}   Match for current git branch"
  echo -e "  ${_C___ERROR}^${_C___RESET}${_C_____DIM}<${_C____PATH}pattern${_C_____DIM}>${_C___RESET}${_C___ERROR}$  ${_C___RESET} Exact match"
  echo -e "  ${_C___ERROR}^${_C___RESET}${_C_____DIM}<${_C____PATH}pattern${_C_____DIM}>   ${_C___RESET} Prefix match"
  echo -e "  ${_C_____DIM} <${_C____PATH}pattern${_C_____DIM}>${_C___RESET}${_C___ERROR}$  ${_C___RESET} Suffix match"
  echo -e "  ${_C_____DIM} <${_C____PATH}pattern${_C_____DIM}>   ${_C___RESET} Substring match"
  echo
  echo -e "${_C_HEADING}Examples:${_C___RESET}"
  echo -ne "  ${_C_COMMAND}gitter${_C___RESET} ${_C__OPTION}--filter repo:^my-repo\$${_C___RESET} ${_C__OPTION}git${_C___RESET} ${_C__OPTION}--${_C___RESET} ${_C____ARGS}status${_C___RESET}"
  echo -e "      - Run ${_C____ARGS}git status${_C___RESET} in the repository named ${_C____PATH}my-repo${_C___RESET}"
  echo -ne "  ${_C_COMMAND}gitter${_C___RESET} ${_C__OPTION}--filter branch:feature${_C___RESET} ${_C__OPTION}exec${_C___RESET} ${_C__OPTION}--${_C___RESET} ${_C____ARGS}make build${_C___RESET}"
  echo -e " - Run ${_C____ARGS}make build${_C___RESET} in repositories currently on any ${_C____PATH}feature${_C___RESET} branch"
  echo -ne "  ${_C_COMMAND}gitter${_C___RESET} ${_C__OPTION}--filter .repo:old-project${_C___RESET} ${_C__OPTION}list${_C___RESET}"
  echo -e "            - List all repositories except the ones has ${_C____PATH}old-project${_C___RESET} in repo name"
  echo
}

__parse_command() {
  if [[ -n "$command" ]]; then
    echo
    echo -e "\n${_C___ERROR}Multiple command types specified${_C___RESET}" 1>&2
    echo
    echo -e "Run ${_C_COMMAND}gitter --help${_C___RESET} for usage information." 1>&2
    echo
    exit 1
  fi
  command="${1}"
}

__accept_no_arg() {
  if [[ -n $1 ]]; then
    echo
    echo -e "${_C___ERROR}Unknown argument:${_C___RESET} $1" 1>&2
    echo
    echo -e "Run ${_C_COMMAND}gitter --help${_C___RESET} for usage information." 1>&2
    echo
    exit 1
  fi
}

__require_value() {
  if [[ -z "$1" || "$1" == -* ]]; then
    echo
    echo -e "${_C___ERROR}Missing or invalid argument for:${_C___RESET} $2" 1>&2
    echo
    echo -e "Run ${_C_COMMAND}gitter --help${_C___RESET} for usage information." 1>&2
    echo
    exit 1
  fi
}

# Argument defaults
no_color=false
command=""
filters=()
args=()

if [[ $# -eq 0 ]]; then
  __help
  exit 1
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --no-color)
      no_color=true
      shift
      ;;
    --filter|-f)
      shift
      __require_value "$1" "${_C__OPTION}--filter${_C___RESET}"
      filters+=("$1")
      shift
      ;;
    git  |g ) __parse_command "git" ; shift ;;
    exec |x ) __parse_command "exec"; shift ;;
    list |ls) __parse_command "list"; shift ;;
    help |h ) __parse_command "help"; shift ;;
    --)
      shift
      while [[ $# -gt 0 ]]; do
        args+=("$1")
        shift
      done
      ;;
    *)
      echo
      echo -e "${_C___ERROR}Unknown argument:${_C___RESET} $1" 1>&2
      echo
      echo -e "Run ${_C_COMMAND}gitter --help${_C___RESET} for usage information." 1>&2
      echo
      exit 1
      ;;
  esac
done

# Disable colors if no_color is set
if [[ $no_color == true ]]; then
  _C___RESET=''
  _C____PATH=''
  _C_COMMAND=''
  _C____ARGS=''
  _C__OPTION=''
  _C_____DIM=''
  _C_SUCCESS=''
  _C___ERROR=''
  _C_HEADING=''
fi

if [[ "$command" == "help" ]]; then
  __help
  exit 0
fi

# Set default command type if none specified
[[ -z "$command" ]] && command="git"

[[ "$command" != "list" && ${#args[@]} -eq 0 ]] && {
  echo
  echo -e "${_C___ERROR}No arguments provided for command:${_C___RESET} $command" 1>&2
  echo
  echo -e "Run ${_C_COMMAND}gitter --help${_C___RESET} for usage information." 1>&2
  echo
  exit 1
}

readarray -d '' -t repo_git_dirs < <(find . -name ".git" -type d -print0)

if [[ ${#repo_git_dirs[@]} -eq 0 ]]; then
  echo -e "${_C___ERROR}${___ERROR_SYMBOL}  No git repositories found in the current directory${_C___RESET}" 1>&2
  exit 1
fi

filtered_repo_git_dirs=()

for repo_git_dir in "${repo_git_dirs[@]}"; do
  # If no filters, include all repositories
  if [[ ${#filters[@]} -eq 0 ]]; then
    filtered_repo_git_dirs+=("$repo_git_dir")
    continue
  fi

  match=false
  for filter in "${filters[@]}"; do
    first_char="${filter:0:1}"
    if [[ "$first_char" == . ]]; then
      include=false
      remainder="${filter:1}"
      filter_key="${remainder%%:*}"
      filter_value="${remainder#*:}"
    else
      include=true
      filter_key="${filter%%:*}"
      filter_value="${filter#*:}"
    fi

    repo_dir="$(dirname "$repo_git_dir")"

    case "$filter_key" in
      P|path  ) value="$repo_dir" ;;
      R|repo  ) value="$(basename "$repo_dir")" ;;
      B|branch) value="$(git -C "$repo_dir" branch --show-current 2>/dev/null)" ;;
      *)
        echo -e "${_C___ERROR}${___ERROR_SYMBOL}  Unknown filter key: ${filter_key}${_C___RESET}" 1>&2
        exit 1
        ;;
    esac

    if __match_filter "$value" "$filter_value"; then
      match=true
      break
    fi
  done

  # Apply include/exclude logic
  if [[ "$include" == true && "$match" == true ]]; then
    filtered_repo_git_dirs+=("$repo_git_dir")
  elif [[ "$include" == false && "$match" == false ]]; then
    filtered_repo_git_dirs+=("$repo_git_dir")
  fi
done

if [[ ${#filtered_repo_git_dirs[@]} -eq 0 ]]; then
  echo -e "${_C___ERROR}${___ERROR_SYMBOL}${_C___RESET}  No git repositories found in the current directory with applied filters" 1>&2
  exit 1
fi

for repo_git_dir in "${filtered_repo_git_dirs[@]}"; do
  repo_dir=$(dirname "$repo_git_dir")
  if [[ "$command" == "list" ]]; then
    __repo_status "$repo_dir"
    continue
  fi
  if [[ "$command" == "git" || "$command" == "exec" ]]; then
    echo -e "${_C_SUCCESS}${_PRIMARY_SYMBOL} (${command} ${args[*]})${_C___RESET} ${_C_____DIM}in${_C___RESET} ${_C____PATH}$repo_dir${_C___RESET}"
    (
      cd "$repo_dir" 2>/dev/null || {
        echo -e "${_C___ERROR}${_PRIMARY_SYMBOL}  Failed to enter: ${repo_dir}${_C___RESET}" 1>&2
        exit 1
      }
      "$command" "${args[@]}" 1> >(__handle_stdout) 2> >(__handle_stderr)
    )
  fi
done