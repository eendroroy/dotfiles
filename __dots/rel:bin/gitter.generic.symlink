#!/usr/bin/env bash

# Copyright (C) Indrajit Roy <eendroroy@gmail.com>
#
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

____CURRENT_DIR=$(pwd)
_SUCCESS_SYMBOL=" ░"
___ERROR_SYMBOL=" ░"
_PRIMARY_SYMBOL=" ━"

_C___RESET='\e[0m'
_C____PATH='\e[35m'
_C_PATH_DM='\e[2;35m'
_C_COMMAND='\e[32m'
_C____ARGS='\e[33m'
_C__OPTION='\e[36m'
_C_____DIM='\e[2;38;5;3m'
_C___VALUE='\e[2;35;1;3m'
_C_SUCCESS='\e[38;5;2m'
_C___ERROR='\e[38;5;9m'
_C_HEADING='\e[1;37m'

__handle_stdout() {
  while IFS= read -r line; do
    printf "${_C_SUCCESS}%s${_C___RESET}  %s\n" "${_SUCCESS_SYMBOL}" "${line}"
  done
}

__handle_stderr() {
  while IFS= read -r line; do
    printf "${_C___ERROR}%s${_C___RESET}  %s\n" "${___ERROR_SYMBOL}" "${line}" 1>&2
  done
}

__match_filter() {
  local value="$1" pattern="$2"

  # Special-case: single '+' matches everything
  [[ "$pattern" == "+" ]] && return 0

  local has_leading has_trailing
  if [[ "$pattern" == \+* ]]; then
    has_leading=1
    pattern="${pattern#\+}"
  fi
  if [[ "$pattern" == *\+ ]]; then
    has_trailing=1
    pattern="${pattern%\+}"
  fi

  [[ -z "$pattern" ]] && return 0

  if [[ -n "$has_leading" && -n "$has_trailing" ]]; then
    [[ "$value" == *"$pattern"* ]]
  elif [[ -n "$has_leading" ]]; then
    [[ "$value" == *"$pattern" ]]
  elif [[ -n "$has_trailing" ]]; then
    [[ "$value" == "$pattern"* ]]
  else
    [[ "$value" == "$pattern" ]]
  fi
}

__print_path() {
  local path
  if [[ -z ${1} ]]; then
    path=${PWD/"${____CURRENT_DIR}"/.}
  else
    path=${1/"${____CURRENT_DIR}"/.}
  fi

  if [[ "$path" == "." ]]; then
    path="$(basename "${____CURRENT_DIR}")"
  else
    echo -ne "${_C_PATH_DM}${path%/*}/${_C___RESET}"
  fi
  echo -ne "${_C____PATH}${path##*/}${_C___RESET}"
}

__repo_status() {
  (
    cd "$1" 2>/dev/null || {
      echo -e "${_C___ERROR}${_PRIMARY_SYMBOL}  Failed to enter: ${1}${_C___RESET}" 1>&2
      exit 1
    }

    echo -ne "$(__print_path)"
    [[ $verbose == true || $2 = true ]] && echo -ne " ${_C_____DIM}on${_C___RESET} ${_C_COMMAND}$(git branch --show-current)${_C___RESET}"
    [[ $verbose == true ]] && echo -ne " ${_C___VALUE}$(git log -1 --format="%h" --abbrev=8)${_C___RESET}"
    [[ $verbose == true ]] && echo -ne " ${_C____ARGS}$(git log -1 --format="%cr")${_C___RESET}"
    [[ $verbose == true ]] && echo -ne " ${_C_____DIM}by${_C___RESET} ${_C__OPTION}$(git log -1 --format="%ae")${_C___RESET}"
  )
}

__parse_command() {
  if [[ -n "$command" ]]; then
    [[ "$debug" == true ]] && {
      echo
      echo -e "${_C_____DIM}Debug:${_C___RESET} Existing command type: ${_C__OPTION}${command}${_C___RESET}"
      echo -e "${_C_____DIM}Debug:${_C___RESET} New command type:      ${_C__OPTION}${1}${_C___RESET}"
    }
    echo
    echo -e "\n${_C___ERROR}Multiple command types specified${_C___RESET}" 1>&2
    echo
    echo -e "Run ${_C_COMMAND}gitter --help${_C___RESET} for usage information." 1>&2
    echo
    exit 1
  fi
  command="${1}"
}

__read_filter() {
  if [[ -z "$1" || "$1" == -* ]]; then
    echo
    echo -e "${_C___ERROR}Missing or invalid argument for:${_C___RESET} ${_C__OPTION}--filter${_C___RESET}" 1>&2
    echo
    echo -e "Run ${_C_COMMAND}gitter --help${_C___RESET} for usage information." 1>&2
    echo
    exit 1
  fi
  filters+=("$1")
}

__set_no_color() {
  [[ -n "$debug" ]] && {
    echo
    echo -e "Colors disabled via '--no-color' option"
    echo
  }
  _C___RESET=''
  _C____PATH=''
  _C_PATH_DM=''
  _C_COMMAND=''
  _C____ARGS=''
  _C__OPTION=''
  _C_____DIM=''
  _C___VALUE=''
  _C_SUCCESS=''
  _C___ERROR=''
  _C_HEADING=''
}

__help() {
  echo
  echo -e "${_C_HEADING}Gitter${_C___RESET}"
  echo -e "  Run git or arbitrary command in multiple git repositories with filters in current directory"
  echo
  echo -e "${_C_HEADING}Usage:${_C___RESET}"
  echo -ne "  ${_C_COMMAND}gitter${_C___RESET} [${_C__OPTION}--exclude${_C___RESET}] [${_C__OPTION}--filter <${_C___VALUE}pattern${_C___RESET}${_C__OPTION}>${_C___RESET} ...] [${_C__OPTION}--<option>${_C___RESET} ...]"
  echo -ne " [${_C__OPTION}git${_C___RESET}|${_C__OPTION}exec${_C___RESET}|${_C__OPTION}list${_C___RESET}|${_C__OPTION}help${_C___RESET}]"
  echo -e " [${_C__OPTION}--${_C___RESET} <${_C____ARGS}args ...${_C___RESET}>]"
  echo
  echo -e "${_C_HEADING}Commands:${_C___RESET}"
  echo -e "  ${_C__OPTION}git   g      ${_C___RESET} Run a git command (${_C____ARGS}default${_C___RESET})"
  echo -e "  ${_C__OPTION}exec  x      ${_C___RESET} Run an arbitrary command"
  echo -e "  ${_C__OPTION}list  ls     ${_C___RESET} List repositories only"
  echo -e "  ${_C__OPTION}      lb     ${_C___RESET} List repositories with branch name"
  echo -e "  ${_C__OPTION}      ll     ${_C___RESET} Equivalent to ${_C__OPTION}list --verbose${_C___RESET} command"
  echo -e "  ${_C__OPTION}help         ${_C___RESET} Show this help menu"
  echo
  echo -e "${_C_HEADING}Options:${_C___RESET}"
  echo -e "  ${_C__OPTION}--filter   -f <${_C___VALUE}pattern${_C___RESET}> ${_C___RESET} Match repo directory name exactly"
  echo -e "  ${_C__OPTION}--exclude  -e           ${_C___RESET} Exclude matched repositories instead of including"
  echo -e "  ${_C__OPTION}--verbose  -v           ${_C___RESET} Enable verbose mode"
  echo -e "  ${_C__OPTION}--no-color              ${_C___RESET} Disable colored output"
  echo
  echo -e "${_C_HEADING}Filers:${_C___RESET}"
  echo -ne "  ${_C_____DIM}<${_C___RESET}${_C___ERROR}prefix${_C___RESET}${_C_____DIM}>${_C___RESET}"
  echo -ne   "${_C_____DIM}<${_C___RESET}${_C_HEADING}:${_C___RESET}${_C_____DIM}>${_C___RESET}"
  echo -ne   "${_C_____DIM}[${_C___RESET}${_C___ERROR}+${_C___RESET}${_C_____DIM}]${_C___RESET}"
  echo -ne   "${_C_____DIM}<${_C___RESET}${_C___VALUE}pattern${_C___RESET}${_C_____DIM}>${_C___RESET}"
  echo -e   "${_C_____DIM}[${_C___RESET}${_C___ERROR}+${_C___RESET}${_C_____DIM}]${_C___RESET}"
  echo
  echo -e "  Prefixes:"
  echo -e "    ${_C___ERROR}path  ${_C___RESET} ${_C___ERROR}P${_C___RESET}   Match for path name"
  echo -e "    ${_C___ERROR}repo  ${_C___RESET} ${_C___ERROR}R${_C___RESET}   Match for repo name"
  echo -e "    ${_C___ERROR}branch${_C___RESET} ${_C___ERROR}B${_C___RESET}   Match for current git branch"
  echo
  echo -e "  Patterns:"
  echo -e "    ${_C___ERROR}+${_C___RESET}          Matches anywhere in the value (default if no anchors specified)"
  echo -e "     ${_C___VALUE}pattern${_C___RESET}${_C___ERROR}+${_C___RESET}  Matches the beginning of the value"
  echo -e "    ${_C___ERROR}+${_C___RESET}${_C___VALUE}pattern${_C___RESET}   Matches the end of the value"
  echo -e "    ${_C___ERROR}+${_C___RESET}${_C___VALUE}pattern${_C___RESET}${_C___ERROR}+${_C___RESET}  Matches substring anywhere in the value"
  echo -e "     ${_C___VALUE}pattern${_C___RESET}   Matches exactly the value"
  echo
  echo -e "${_C_HEADING}Ignore-file:${_C___RESET}"
  echo -e "  Gitter will look for a ${_C____PATH}.gitterignore${_C___RESET} file ${_C____ARGS}in the current directory.${_C___RESET}"
  echo -e "  If found, it will read patterns from the file to ignore matching repositories."
  echo -e "  Each line in the file should contain a pattern to match repository names or paths."
  echo -e "  Lines starting with ${_C___ERROR}#${_C___RESET} are treated as comments and ignored."
  echo -e "  Patterns:"
  echo -e "    ${_C___ERROR}relative/path/to/directory${_C___RESET} - Ignore directory at exact relative path ${_C____PATH}relative/path/to/directory${_C___RESET}"
  echo -e "    ${_C___ERROR}*/directory_name${_C___RESET}           - Ignore directories under any parent directory named ${_C____PATH}directory_name${_C___RESET}"
  echo -e "    ${_C___ERROR}directory_name/*${_C___RESET}           - Ignore directories directly under the top-level directory named ${_C____PATH}directory_name${_C___RESET}"
  echo
  echo -e "${_C_HEADING}Placeholders:${_C___RESET}"
  echo -e "  Within ${_C__OPTION}exec${_C___RESET} and ${_C__OPTION}git${_C___RESET} commands, the following placeholders can be used in arguments:"
  echo -e "    ${_C____ARGS}{_repo_}${_C___RESET}       - Name of the current git repository"
  echo -e "    ${_C____ARGS}{_path_}${_C___RESET}       - Relative path of the current working directory from where gitter was invoked"
  echo -e "    ${_C____ARGS}{_path:abs_}${_C___RESET}   - Absolute path of the current working directory"
  echo -e "    ${_C____ARGS}{_branch_}${_C___RESET}     - Current git branch name"
  echo
}

# Argument defaults
filters=()
exclude=false
debug=false
command=""
verbose=false
branch=false
args=()

# Commands
___git()  { __parse_command "git" ; }
___exec() { __parse_command "exec"; }
___list() { __parse_command "list"; }
___help() { __parse_command "help"; }

# Command aliases
___lb()   { __parse_command "list"; branch=true; }
___ll()   { __parse_command "list"; verbose=true; }

if [[ $# -eq 0 ]]; then
  __help
  exit 1
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    # Parse Options
    --exclude |-e ) exclude=true;              shift ;;
    --filter  |-f ) shift; __read_filter "$1"; shift ;;
    --no-color    ) __set_no_color;            shift ;;
    --verbose |-v ) verbose=true;              shift ;;
    --debug       ) debug=true;                shift ;;

    # Parse Commands
    git  |g  ) ___git;  shift ;;
    exec |x  ) ___exec; shift ;;
    list |ls ) ___list; shift ;;
          lb ) ___lb;   shift ;;
          ll ) ___ll;   shift ;;
    help     ) ___help; shift ;;
    --)
      shift
      while [[ $# -gt 0 ]]; do
        args+=("$1")
        shift
      done
      ;;
    *)
      echo
      echo -e "${_C___ERROR}Unknown argument:${_C___RESET} $1" 1>&2
      echo
      echo -e "Run ${_C_COMMAND}gitter --help${_C___RESET} for usage information." 1>&2
      echo
      exit 1
      ;;
  esac
done

if [[ "$command" == "help" ]]; then
  __help
  exit 0
fi

# Set default command type if none specified
[[ -z "$command" ]] && command="git"

[[ "$command" != "list" && ${#args[@]} -eq 0 ]] && {
  echo
  echo -e "${_C___ERROR}No arguments provided for command:${_C___RESET} $command" 1>&2
  echo
  echo -e "Run ${_C_COMMAND}gitter --help${_C___RESET} for usage information." 1>&2
  echo
  exit 1
}

readarray -d '' -t repo_git_dirs < <(find . -name ".git" -type d -print0)

# If .gitterignore exists, load patterns and remove matching repos from the list.
if [[ -f .gitterignore ]]; then
  # Load non-empty, non-comment lines from .gitterignore
  mapfile -t ignore_patterns < <(sed -e 's/#.*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e '/^$/d' .gitterignore)

  # If there are patterns, filter repo_git_dirs accordingly.
  if [[ ${#ignore_patterns[@]} -gt 0 ]]; then
    kept_repo_git_dirs=()
    for repo_git_dir in "${repo_git_dirs[@]}"; do
      git_repo_dir_name="$(dirname "${repo_git_dir#./}")"
      for pattern in "${ignore_patterns[@]}"; do
        if [[ "$pattern" == '*/'* ]]; then
          # find all folder tree and match each folder in the path
          IFS='/' read -r -a path_parts <<< "$git_repo_dir_name"
          ignore=false
          for part in "${path_parts[@]}"; do
            if [[ "$part" == "${pattern#*/}" ]]; then
              ignore=true
              break
            fi
          done
          [[ "$ignore" == true ]] && break
        elif [[ "$pattern" == *'/*' ]]; then
          # find only the parent folder
          parent_dir="${git_repo_dir_name%%/*}"
          if [[ "$parent_dir" == "${pattern%/*}" ]]; then
            ignore=true
            break
          fi
        else
          # direct match with repo name
          repo_name="$(basename "$(dirname "$repo_git_dir")")"
          if [[ "$repo_name" == "$pattern" ]]; then
            ignore=true
            break
          fi
          # direct match with relative path
          if [[ "$git_repo_dir_name" == "$pattern" ]]; then
            ignore=true
            break
          fi
        fi
      done

      [[ "$ignore" == false ]] && kept_repo_git_dirs+=("$repo_git_dir")
    done

    repo_git_dirs=("${kept_repo_git_dirs[@]}")
  fi
fi

if [[ ${#repo_git_dirs[@]} -eq 0 ]]; then
  echo -e "${_C___ERROR}${___ERROR_SYMBOL}  No git repositories found in the current directory${_C___RESET}" 1>&2
  exit 1
fi

filtered_repo_git_dirs=()

for repo_git_dir in "${repo_git_dirs[@]}"; do

  [[ "$debug" == true ]] && {
    echo -e "${_C_____DIM}Debug:${_C___RESET} Processing repository: ${_C____PATH}$(dirname "$repo_git_dir")${_C___RESET}"
  }

  if [[ ${#filters[@]} -eq 0 ]]; then
    [[ "$debug" == true ]] && {
      echo -e "${_C_____DIM}Debug:${_C___RESET} No filters specified, including repository: ${_C____PATH}$(dirname "$repo_git_dir")${_C___RESET} by default"
      echo
      echo
    }
    filtered_repo_git_dirs+=("$repo_git_dir")
    continue
  fi

  match=false
  for filter in "${filters[@]}"; do
    [[ "$debug" == true ]] && {
      echo -e "${_C_____DIM}Debug:${_C___RESET} Applying filter: ${_C__OPTION}${filter}${_C___RESET}"
    }

    filter_key="${filter%%:*}"
    filter_value="${filter#*:}"

    repo_dir="$(dirname "$repo_git_dir")"

    case "$filter_key" in
      P|path  ) value="$repo_dir" ;;
      R|repo  ) value="$(basename "$repo_dir")" ;;
      B|branch) value="$(git -C "$repo_dir" branch --show-current 2>/dev/null)" ;;
      *)
        echo -e "${_C___ERROR}${___ERROR_SYMBOL}  Unknown filter key: ${filter_key}${_C___RESET}" 1>&2
        exit 1
        ;;
    esac

    if __match_filter "$value" "$filter_value"; then
      [[ "$debug" == true ]] && {
        echo -e "${_C_____DIM}Debug:${_C___RESET} Filter matched: ${_C__OPTION}${filter}${_C___RESET} for value: ${_C____PATH}${value}${_C___RESET}"
      }
      match=true && break
    fi
  done

  if [[ "$exclude" == false && "$match" == true ]]; then
    [[ "$debug" == true ]] && {
      echo -e "${_C_____DIM}Debug:${_C___RESET} Including repository: ${_C____PATH}$(dirname "$repo_git_dir")${_C___RESET}"
    }
    filtered_repo_git_dirs+=("$repo_git_dir")
  fi

  if [[ "$exclude" == true && "$match" == false ]]; then
    [[ "$debug" == true ]] && {
      echo -e "${_C_____DIM}Debug:${_C___RESET} Including repository: ${_C____PATH}$(dirname "$repo_git_dir")${_C___RESET}"
    }
    filtered_repo_git_dirs+=("$repo_git_dir")
  fi

  [[ "$debug" == true ]] && {
    echo
    echo
  }
done

if [[ ${#filtered_repo_git_dirs[@]} -eq 0 ]]; then
  echo -e "${_C___ERROR}${___ERROR_SYMBOL}${_C___RESET}  No git repositories found in the current directory with applied filters" 1>&2
  exit 1
fi

if [[ "$command" == "list" ]]; then
  for repo_git_dir in "${filtered_repo_git_dirs[@]}"; do
    repo_dir=$(dirname "$repo_git_dir")
    echo -ne "${_C_SUCCESS}${_PRIMARY_SYMBOL}${_C___RESET} "
    __repo_status "$repo_dir" "$branch"
    echo
    continue
  done
  exit 0
fi

# Remaining commands: git, exec
[[ "$command" == "exec" ]] && command="${args[0]}" && args=("${args[@]:1}")

for repo_git_dir in "${filtered_repo_git_dirs[@]}"; do
  repo_dir=$(dirname "$repo_git_dir")
  (
    cd "$repo_dir" 2>/dev/null || {
      echo -e "${_C___ERROR}${_PRIMARY_SYMBOL}  Failed to enter: ${_C___RESET} $(__print_path "$repo_dir")" 1>&2
      exit 1
    }

    parsed_args=()
    for arg in "${args[@]}"; do
      # {_repo_} -> name of the current git repository
      [[ $arg == *"{_repo_}"* ]] && arg="${arg//\{_repo_\}/$(basename "$(pwd)")}"

      # {_path_} -> relative path of the current working directory from where gitter was invoked
      [[ $arg == *"{_path_}"* ]] && arg="${arg//\{_path_\}/${PWD/"${____CURRENT_DIR}"/.}}"

      # {_path:abs_} -> absolute path of the current working directory}
      [[ $arg == *"{_path:abs_}"* ]] && arg="${arg//\{_path:abs_\}/$(pwd)}"

      # {_branch_} -> current git branch name
      [[ $arg == *"{_branch_}"* ]] && arg="${arg//\{_branch_\}/$(git branch --show-current 2>/dev/null)}"

      [[ "$debug" == true ]] && {
        echo -e "${_C_____DIM}Debug:${_C___RESET} Parsed argument: ${_C____ARGS}${arg}${_C___RESET}"
      }

      parsed_args+=("$arg")
    done

    [[ "$debug" == true ]] && {
      echo -e "${_C_____DIM}Debug:${_C___RESET} in:                ${_C____PATH}$(pwd)${_C___RESET}"
      echo -e "${_C_____DIM}Debug:${_C___RESET} Received command:  ${_C_COMMAND}${command} ${args[*]}${_C___RESET}"
      echo -e "${_C_____DIM}Debug:${_C___RESET} Executing command: ${_C_COMMAND}${command} ${parsed_args[*]}${_C___RESET}"
    }

    echo -e "${_C_SUCCESS}${_PRIMARY_SYMBOL} \$(${command} ${parsed_args[*]})${_C___RESET} ${_C_____DIM}in${_C___RESET} $(__repo_status ".")"
    command -- "$command" "${parsed_args[@]}" 1> >(__handle_stdout) 2> >(__handle_stderr)
  )
done
exit 0